<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>This is a blog post version of the <a href="https://arxiv.org/abs/2501.08319" rel="external nofollow noopener" target="_blank">paper</a> we wrote on the same topic.</p> <h3 id="introduction">Introduction</h3> <p>Understanding the inner workings of large language models (LLMs) involves analyzing their internal representations at various levels of granularity. One approach focuses on analyzing “<strong>features</strong>”—generalized computational units, such as <strong>neurons</strong>, which potentially offer a precise lens for interpreting the model’s behavior.</p> <div id="binding-demo-root" data-mode="interactive" data-show-title="true" data-initial-n="12"></div> <link rel="stylesheet" href="/assets/css/binding-demo/index-BEOe_g9O.css"> <script type="module" defer src="/assets/js/binding-demo/index-B_g5bwzp.js"></script> <h3 id="focusing-on-the-output">Focusing on the Output</h3> <p>The first method, dubbed <code class="language-plaintext highlighter-rouge">VocabProj</code>, is simply applying vocabulary projection (a.k.a. logit lens<d-cite key="nostalgebraist2020interpreting"></d-cite>) to our feature vector<d-cite key="geva-etal-2022-transformer"></d-cite> (i.e. the relevant row vector in the MLP out matrix, or the SAE decode matrix). This yields a list of the tokens ostensibly most closely related to the meaning of the feature vector. We can then pass this list to an explainer model (e.g. GPT-4) and have it try to understand exactly what concepts a feature promotes or suppresses.</p> <p>The second method, dubbed <code class="language-plaintext highlighter-rouge">TokenChange</code>, takes a more causal approach. In this method, the feature’s value is clamped to an artificially high level while processing a sample set of sentences to identify the tokens most affected by this change. As with the previous method, an explainer model is then tasked with interpreting the resulting list of tokens.</p> <p>These two methods are inexpensive to run, and provide us with insights regarding how a feature actually affects the model. Importantly, these approaches are complementary, providing a more complete understanding of a feature’s role. For instance, consider the MLP SAE feature <code class="language-plaintext highlighter-rouge">19/5635</code> from Gemma-2 2B. The inputs that most activate this feature are ‘‘<em>Inauguration</em>”, “<em>Election</em>”, “<em>Race</em>”, “<em>funeral</em>” and “<em>opening</em>”, suggesting a connection to events. Meanwhile, the tokens most associated with its outputs are “<em>week</em>”, “<em>weekend</em>”, “<em>day</em>”, “<em>month</em>” and “<em>year</em>”, pointing to time measurements. Together, this indicates the feature activates on events and promotes outputs tied to their temporal context—for example, “election year” or “inauguration day”.</p> <h3 id="evaluating-descriptions">Evaluating Descriptions</h3> <p>To evaluate these feature descriptions, we propose an input-based evaluation and an output based one. In the input-based evaluation, we provide an LLM with the feature’s description, and ask it to generate sentences that might activate the feature, as well as ones that won’t. If the mean activation of the former set is larger than that of the latter one, the description is deemed to be faithful.</p> <p>In the output-based evaluation, we amplify the target feature and observe its influence on the model’s generated text. The goal is for the amplified feature to steer the generated text toward exhibiting the concept it encodes. For example, amplifying a feature associated with ‘games’ should prompt the model to generate text related to games. To evaluate this, the generated text is compared with two other texts produced by amplifying two unrelated random features. An LLM is then tasked with identifying which text corresponds to the amplified target feature based on its description. If it answers correctly, the description is deemed to be faithful.</p> <h3 id="results">Results</h3> <p>Unsurprisingly, each method excels in its own category. The input-centric method <code class="language-plaintext highlighter-rouge">MaxAct</code> outperforms the output-centric ones on the input-based metric, while the output-centric methods <code class="language-plaintext highlighter-rouge">VocabProj</code> and <code class="language-plaintext highlighter-rouge">TokenChange</code> outperform <code class="language-plaintext highlighter-rouge">MaxAct</code> on the output-based metric.</p> <p>Remarkably, an ensemble of the three methods performs better than all individual methods on both metrics! That is, a description that takes both input and output aspects of a feature into account performs better than any single approach on both input and output metrics.</p> <div class="l-page" style="display: flex; justify-content: center;"> <iframe src="/assets/plotly/enhancing_results.html" frameborder="0" scrolling="no" height="400px" width="760px" style="border: 1px dashed grey;"></iframe> </div> <h3 id="conclusion">Conclusion</h3> <p>We showed that the output-centric methods <code class="language-plaintext highlighter-rouge">VocabProj</code> and <code class="language-plaintext highlighter-rouge">TokenChange</code> consistently outperform <code class="language-plaintext highlighter-rouge">MaxAct</code> in output-based evaluations, highlighting the limitations of <code class="language-plaintext highlighter-rouge">MaxAct</code> in capturing the causal role of features. Additionally, these methods are significantly more computationally efficient and often approach <code class="language-plaintext highlighter-rouge">MaxAct</code>’s performance on input-based metrics, making them a practical and cost-effective alternative. Finally, we showed how <code class="language-plaintext highlighter-rouge">VocabProj</code> and <code class="language-plaintext highlighter-rouge">TokenChange</code> enhance automated interpretability pipelines by delivering more faithful feature descriptions across both evaluation dimensions.</p> <p>For a demonstration of how understanding a feature translates into real-world applications, have a look at <a href="https://yoav.ml/blog/2025/sae-knowledge-erasure/" rel="external nofollow noopener" target="_blank">this</a> blog post showcasing how it can facilitate knowledge erasure in LLMs. For more details about this work you can read our <a href="https://arxiv.org/abs/2501.08319" rel="external nofollow noopener" target="_blank">paper</a>.</p> </body></html>